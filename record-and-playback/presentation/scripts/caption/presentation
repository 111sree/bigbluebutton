#!/usr/bin/ruby
# frozen_string_literal: true

# Copyright Â© 2019 BigBlueButton Inc. and by respective authors.
#
# This file is part of the BigBlueButton open source conferencing system.
#
# BigBlueButton is free software: you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# BigBlueButton is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with BigBlueButton.  If not, see <https://www.gnu.org/licenses/>.

require 'rubygems'
require 'bundler/setup'

require 'optparse'
require 'journald/logger'

# Parse command-line options

recording_id = nil
OptionParser.new do |opts|
  opts.on('--record-id=REC', 'Recording ID to copy captions into') do |rec|
    recording_id = rec
  end
end.parse!

unless recording_id
  warn('--record-id was not specified')
  exit(1)
end

# Read configuration and set up logger

props = File.open(File.expand_path('../bigbluebutton.yml', __dir__)) do |bbb_yml|
  YAML.safe_load(bbb_yml)
end
presentation_props = File.open(File.expand_path('../presentation.yml', __dir__)) do |pres_yml|
  YAML.safe_load(pres_yml)
end

logger = Journald::Logger.new('caption/presentation')
logger.tag(record_id: recording_id)

unless props['captions_dir']
  logger.error('captions_dir was not defined in bigbluebutton.yml')
  exit(1)
end

recording_dir = props['recording_dir']
captions_dir = File.join(props['captions_dir'], recording_id)
publish_dir = File.join(presentation_props['publish_dir'], recording_id)

unless File.directory?(publish_dir)
  logger.error('Published recording directory for this recording does not exist')
  exit(0)
end

# Load the captions index file and recording playback caption list

begin
  logger.info('Loading recording playback captions list')
  playback_captions_path = File.join(publish_dir, 'captions.json')
  playback_captions = JSON.parse(IO.read(playback_captions_path))
rescue Errno::ENOENT
  logger.info("Playback doesn't have a captions.json - old playback format version?")
  logger.info('Triggering recording reprocessing.')
  archive_done_file = "#{recording_dir}/status/archived/#{recording_id}.done"
  File.open(archive_done_file, 'w') do |archive_done|
    archive_done.write('Reprocessing for captions')
  end
  # Treat this as success, the captions will be integrated during reprocessing
  exit(0)
end

# Captions index file
begin
  logger.info('Loading captions index file')
  captions_path = File.join(captions_dir, 'captions.json')
  captions = File.open(captions_path) do |json|
    JSON.parse(json.read)
  end
rescue Errno::ENOENT
  logger.info('No captions index file found, nothing to do.')
  exit(0)
end

# Copy the new caption files over the existing ones in the playback

captions.each do |caption|
  kind = caption['kind']
  lang = caption['lang']
  label = caption['label']

  logger.info("Copying file for kind=#{kind} lang=#{lang}")
  FileUtils.cp(File.join(captions_dir, "#{kind}_#{lang}.vtt"), publish_dir)

  # Remove any existing matching tracks from the playback captions list...
  playback_captions.reject! do |playback_caption|
    playback_caption['locale'] == lang &&
      (playback_caption['kind'] == kind || (playback_caption['kind'].nil? && kind == 'captions'))
  end
  # ...and add the new one.
  playback_captions << {
    'kind'       => kind,
    'locale'     => lang,
    'localeName' => label,
  }
end

logger.info('Saving updated playback captions list')
# Sort the list by label so the selection menu looks nice
playback_captions.sort { |a, b| a['localeName'] <=> b['localeName'] }
IO.write(playback_captions_path, JSON.pretty_generate(playback_captions))
